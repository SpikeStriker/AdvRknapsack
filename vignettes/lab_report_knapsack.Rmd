
---
title: "lab_report_knapsack"
output:
  pdf_document: 
    latex_engine: pdflatex
vignette: >
  %\VignetteIndexEntry{lab_report_knapsack}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(AdvRknapsack)
```

# Introduction

This vignette provides a comprehensive overview of the `AdvRknapsack` package, which offers solutions to the classic knapsack problem using three different algorithms: Brute-Force, Greedy, and Dynamic Programming. Each approach has its own strengths and trade-offs, depending on the size and nature of the input data.

## Brute-Force Approach

The brute-force approach attempts every possible combination of items to find the optimal solution. While this guarantees the best solution, it is computationally expensive, especially for larger datasets.

### Usage

```{r brute_force_example}
# Prepare Data
set.seed(42)
knapsack_objects <- data.frame(w = sample(1:4000, size = 1000000, replace = TRUE), v = runif(n = 1000000, min = 0, max = 10000))

# Run Brute-Force Knapsack
result <- brute_force_knapsack(x = knapsack_objects[1:8, ], W = 3500)
print(result)
result <- brute_force_knapsack(x = knapsack_objects[1:12, ], W = 3500)
print(result)
result <- brute_force_knapsack(x = knapsack_objects[1:8, ], W = 2000)
print(result)
result <- brute_force_knapsack(x = knapsack_objects[1:12, ], W = 2000)
print(result)
```
```{r brute_force_timing}
# Measure execution time for brute-force knapsack
time_taken <- system.time({
  result <- brute_force_knapsack(x = knapsack_objects[1:16, ], W = 2000)
})

# Display the results
print(result)
print(time_taken)
```
**How much time does it takes to run the algorithm for n = 16 objects?**  
Time taken: `r time_taken[3]` seconds

## Dynamic Programming Approach

Dynamic programming breaks the problem into smaller sub-problems and builds up the solution iteratively. It guarantees an optimal solution with improved efficiency over brute-force.

### Usage

```{r dynamic_example}
# Run Dynamic Knapsack
result <- knapsack_dynamic(x = knapsack_objects[1:500, ], W = 2000)
print(result)
```

```{r dynamic_timing}
# Measure execution time for Greedy Approach
time_taken <- system.time({
  result <- knapsack_dynamic(x = knapsack_objects[1:500, ], W = 2000)
})

print(result)
print(time_taken)
```
**How much time does it takes to run the algorithm for n = 500 objects?**  
Time taken: `r time_taken[3]` seconds



## Greedy Approach

The greedy algorithm sorts items based on their value-to-weight ratio and picks the best option. While fast, it does not always yield the optimal solution.

### Usage

```{r greedy_example}
# Run Greedy Knapsack
result <- greedy_knapsack(x = knapsack_objects[1:800, ], W = 3500)
print(result)

result <- greedy_knapsack(x = knapsack_objects[1:1200, ], W = 2000)
print(result)
```

```{r greedy_timing}
# Measure execution time for Greedy Approach
time_taken <- system.time({
  result <- greedy_knapsack(x = knapsack_objects[1:1000000, ], W = 2000)
})

print(result)
print(time_taken)
```
**How much time does it takes to run the algorithm for n = 1000000 objects?**  
Time taken: `r time_taken[3]` seconds




## Comparing the Methods

The choice of algorithm depends on the problem size and requirements:

- **Brute-Force**: Suitable for small datasets where exact results are required.
- **Dynamic Programming**: Ideal for medium-sized datasets where an optimal solution is desired with reasonable computational effort.
- **Greedy**: Good for larger datasets when a near-optimal solution suffices.


## Conclusion

The `AdvRknapsack` package provides flexible options for solving the knapsack problem using different algorithms, catering to various performance needs and dataset sizes.
